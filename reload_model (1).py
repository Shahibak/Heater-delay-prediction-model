# -*- coding: utf-8 -*-
"""Reload model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V3tJ13NwWf9KjDINu7Q4Jr4int9XJ372
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow import keras
from tensorflow.keras import layers
from keras.layers import TFSMLayer

"""Inserting NN predictive model:"""

new_model = keras.models.load_model('dnn_model.keras')

"""# **Change the input parameters here:**

"""

Bp = 17 # Magnet field
fcusc = 2.2 # Fraction of copper to superconductor
fraG = 0.15 # Fraction of G10
tG10 = 0.5 # Thickness of G10
tka = 0.1 # Thickness of kapton
tau = 12 # Time constant
Wcoil = 15 # Width of the coil
jhea = 350 # Heater power
Im = 10000 # Magnet current

Ics = [Im] # Magnet current

# Define the function that calculates Ic for a given T
def calculate_Ic(T, Bp, fcusc, fraG):
    th = 0.00131  # thickness of the cable
    tcoil = 0.01273  # width of the cable
    CS = th * tcoil  # cross section
    fsc = 1 / (fcusc + 1)
    Ain = CS * fraG
    Asc = (CS - Ain) * fsc
    BC20 = 29.38
    C0 = 1.955e11
    TC0 = 16.0
    alpha = 0.96
    BC2 = 0.0

    Tred = T / TC0
    BC2 = BC20 * (1 - (Tred) ** 1.52)
    C = C0 * (1 - (Tred) ** 1.52) ** alpha * (1 - (Tred) ** 2) ** alpha
    bred = Bp / BC2
    Ic = ((C / Bp) * bred ** 0.5 * (1 - bred) ** 2) * Asc

    return Ic

# Define a function to find the closest T value for a given Ic
def find_closest_T(Ic, Bp, fcusc, fraG):
    # Generate a range of temperatures
    temperatures = np.arange(3, 17, 0.02)

    # Initialize variables to store closest T and corresponding Ic
    closest_T = None
    closest_Ic = None
    min_difference = float('inf')

    # Iterate through each temperature and calculate corresponding Ic
    for T in temperatures:
        calculated_Ic = calculate_Ic(T, Bp, fcusc, fraG)

        # Check the absolute difference between calculated Ic and target Ic
        difference = abs(calculated_Ic - Ic)

        # Update closest T and Ic if the current difference is smaller
        if difference < min_difference:
            min_difference = difference
            closest_T = T
            closest_Ic = calculated_Ic

    return closest_T, closest_Ic

Ic = 0000  # Example value for given Ic

closest_T, closest_Ic = find_closest_T(Ic, Bp, fcusc, fraG)

Tc = closest_T
Tc

def surface(Bp, fcusc, fraG, target_Ic_values):
    th = 0.00131 ## thickness of the cable
    tcoil = 0.01273 ## width of the cable
    CS = th * tcoil ### cross section
    Ain = CS * fraG
    fsc = 1 / (fcusc + 1)
    Asc = (CS - Ain) * fsc
    BC20 = 29.38
    C0 = 1.955e11
    TC0 = 16.0
    alpha = 0.96
    BC2 = 0.0
    Tred = 0.0
    Tcs_value = []

    for target_Ic in Ics:
        min_difference = float('inf')
        nearest_T = None

        for T in np.arange(1, Tc, 0.025):  # Adjusted the range with smaller time steps
            Tred = T / TC0
            BC2 = BC20 * (1 - (Tred) ** 1.52)
            C = C0 * (1 - (Tred) ** 1.52) ** alpha * (1 - (Tred) ** 2) ** alpha

            bred = Bp / BC2  # Added missing assignment

            Ic = ((C / Bp) * bred ** 0.5 * (1 - bred) ** 2) * Asc  # Corrected bred(T) to bred

            # Check the difference between current Ic and target_Ic
            difference = abs(Ic - target_Ic)

            # Update nearest_T if the current difference is smaller
            if difference < min_difference:
                min_difference = difference
                nearest_T = T

        Tcs_value.append(nearest_T)

    return Tcs_value

Tcs_value = surface(Bp, fcusc, fraG, Ics)
print(Tcs_value)

# Maximum and minimum value of each variable in the dataset
min_values = [0.8, 0.1, 0.025, 200.0, 0.1, 10.0, 12.73, 1.0, 5.0]
max_values = [2.2, 0.2, 0.075, 600.0, 0.22, 45.0, 20.0, 17.0, 16.0]

normalized_data = []

                        #fcusc   t_G10   t_kapton     jheater     G10_percentage     tau      W coil   B   TCS
non_normalized_data  = [ fcusc,     tG10,     tka,       jhea,          fraG,           tau ,      Wcoil,    Bp,  Tcs_value[0]  ]


# Assuming non_normalized_data, min_values, and max_values are lists or arrays defined elsewhere

for i in range(len(non_normalized_data)):
    # Apply min-max normalization formula
    j = (non_normalized_data[i] - min_values[i]) / (max_values[i] - min_values[i])
    # Append normalized value to the list
    normalized_data.append(j)

print (normalized_data)

####Prediction

# Convert the list to a NumPy array
non_normalized_array = np.array(normalized_data)


# Reshape the input array according to the model's input shape
# For example, if your model expects input shape (7,), reshape it to (1, 7)
# Adjust the shape according to your model's input requirements
input_data = non_normalized_array.reshape(1, -1)

# Make predictions using the model
predictions = new_model.predict(input_data)

"""# **Heater delay prediction:**"""

if Tcs_value[0] == 1.0:
  print("Attention: current shearing temperature is more than critical temperature!!")
  print("Determined heater delay might be wrong!!")
  print("     ")
elif predictions > 50:
  print("Attention: The predictive model is less accurate for the heater delay more than 50 ms!!")
  print("     ")


print("Prediction value for heater delay is:", predictions)